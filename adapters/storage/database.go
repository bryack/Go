package storage

import (
	"database/sql"
	"fmt"
	"log/slog"
	infraErrors "myproject/infrastructure/errors"
	"myproject/internal/domain"
	"myproject/logger"
	"os"
	"time"
)

// DatabaseStorage provides SQLite-based task persistence with automatic migrations.
type DatabaseStorage struct {
	db       *sql.DB
	migrator *Migrator
	logger   *slog.Logger
}

// GetDatabasePath returns the database file path from TASK_DB_PATH env or "./tasks.db".
func GetDatabasePath() string {
	if dbPath := os.Getenv("TASK_DB_PATH"); dbPath != "" {
		return dbPath
	}
	return "./tasks.db"
}

// NewDatabaseStorage creates a new database storage with connection pooling and migrations.
func NewDatabaseStorage(dbPath string, logger *slog.Logger) (*DatabaseStorage, error) {
	config := ConnectionConfig{
		MaxOpenConns:    25,
		MaxIdleConns:    5,
		ConnMaxLifetime: time.Hour,
		ConnMaxIdleTime: 15 * time.Minute,
	}
	db, err := CreateConnection(&config, dbPath)
	if err != nil {
		return nil, mapSQLiteError(err)
	}

	logger.Info("Database connection established",
		slog.String("db_path", dbPath),
	)

	migrator := NewMigratorWithDefaults(db)

	logger.Info("Applying database migrations")
	if err := migrator.ApplyMigrations(); err != nil {
		return nil, err
	}
	logger.Info("Database migrations completed")

	// Create storage instance
	storage := &DatabaseStorage{
		db:       db,
		migrator: migrator,
		logger:   logger,
	}
	return storage, nil
}

// CreateTask inserts a new task and returns the generated ID.
func (ds *DatabaseStorage) CreateTask(task domain.Task, userID int) (int, error) {
	ds.logger.Debug("Creating task",
		slog.String(logger.FieldOperation, "create_task"),
		slog.Int(logger.FieldUserID, userID),
		slog.String("description", task.Description),
	)
	result, err := ds.db.Exec(
		"INSERT INTO tasks (description, done, user_id) VALUES (?, ?, ?)",
		task.Description, task.Done, userID,
	)
	if err != nil {
		ds.logger.Error("Failed to execute database insert",
			slog.String(logger.FieldOperation, "create_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return 0, mapSQLiteError(err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		ds.logger.Error("Failed to return id generated by database",
			slog.String(logger.FieldOperation, "create_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return 0, mapSQLiteError(err)
	}
	return int(id), nil
}

// UpdateTask modifies a task's description and status, returns ErrTaskNotFound if not owned by user.
func (ds *DatabaseStorage) UpdateTask(task domain.Task, userID int) error {
	ds.logger.Debug("Updating task",
		slog.String(logger.FieldOperation, "update_task"),
		slog.Int(logger.FieldTaskID, task.ID),
		slog.Int(logger.FieldUserID, userID),
		slog.Bool("done", task.Done),
	)
	result, err := ds.db.Exec(
		"UPDATE tasks SET description = ?, done = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?",
		task.Description, task.Done, task.ID, userID,
	)
	if err != nil {
		ds.logger.Error("Failed to execute database update",
			slog.String(logger.FieldOperation, "update_task"),
			slog.Int(logger.FieldTaskID, task.ID),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return mapSQLiteError(err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		ds.logger.Error("Failed to affect database row",
			slog.String(logger.FieldOperation, "update_task"),
			slog.Int(logger.FieldTaskID, task.ID),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return mapSQLiteError(err)
	}
	ds.logger.Debug("Database operation completed: affected rows",
		slog.String(logger.FieldOperation, "update_task"),
		slog.Int(logger.FieldTaskID, task.ID),
		slog.Int(logger.FieldUserID, userID),
		slog.Bool("done", task.Done),
		slog.Int64("rows_affected", rowsAffected),
	)

	if rowsAffected == 0 {
		return infraErrors.ErrTaskNotFound
	}

	return nil
}

// DeleteTask removes a task by ID, returns ErrTaskNotFound if not owned by user.
func (ds *DatabaseStorage) DeleteTask(id int, userID int) error {
	ds.logger.Debug("Deleting task",
		slog.String(logger.FieldOperation, "delete_task"),
		slog.Int(logger.FieldTaskID, id),
		slog.Int(logger.FieldUserID, userID),
	)
	result, err := ds.db.Exec(
		"DELETE FROM tasks WHERE id = ? AND user_id = ?",
		id, userID,
	)
	if err != nil {
		ds.logger.Error("Failed to execute database delete",
			slog.String(logger.FieldOperation, "delete_task"),
			slog.Int(logger.FieldTaskID, id),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return mapSQLiteError(err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		ds.logger.Error("Failed to affect database row",
			slog.String(logger.FieldOperation, "delete_task"),
			slog.Int(logger.FieldTaskID, id),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return mapSQLiteError(err)
	}
	ds.logger.Debug("Database operation completed: affected rows",
		slog.String(logger.FieldOperation, "delete_task"),
		slog.Int(logger.FieldTaskID, id),
		slog.Int(logger.FieldUserID, userID),
		slog.Int64("rows_affected", rowsAffected),
	)

	if rowsAffected == 0 {
		return infraErrors.ErrTaskNotFound
	}

	return nil
}

// GetTaskByID retrieves a task by ID, returns ErrTaskNotFound if not owned by user.
func (ds *DatabaseStorage) GetTaskByID(id int, userID int) (task domain.Task, err error) {
	ds.logger.Debug("Fetching task",
		slog.String(logger.FieldOperation, "get_task_by_id"),
		slog.Int(logger.FieldTaskID, id),
		slog.Int(logger.FieldUserID, userID),
	)
	err = ds.db.QueryRow(
		"SELECT id, description, done FROM tasks WHERE id = ? AND user_id = ?",
		id, userID,
	).Scan(&task.ID, &task.Description, &task.Done)

	if err != nil {
		if err == sql.ErrNoRows {
			return domain.Task{}, infraErrors.ErrTaskNotFound
		}
		ds.logger.Error("Failed to query database select from tasks",
			slog.String(logger.FieldOperation, "get_task_by_id"),
			slog.Int(logger.FieldTaskID, id),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return domain.Task{}, mapSQLiteError(err)
	}

	return task, nil
}

// LoadTasks retrieves all tasks for a user ordered by ID.
func (ds *DatabaseStorage) LoadTasks(userID int) ([]domain.Task, error) {
	ds.logger.Debug("Loading tasks",
		slog.String(logger.FieldOperation, "load_task"),
		slog.Int(logger.FieldUserID, userID),
	)
	query := "SELECT id, description, done FROM tasks WHERE user_id = ? ORDER BY done ASC, created_at DESC"
	rows, err := ds.db.Query(query, userID)
	if err != nil {
		ds.logger.Error("Failed to query database select",
			slog.String(logger.FieldOperation, "load_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return nil, mapSQLiteError(err)
	}

	defer rows.Close()
	tasks := make([]domain.Task, 0)
	for rows.Next() {
		var task domain.Task
		if err := rows.Scan(&task.ID, &task.Description, &task.Done); err != nil {
			ds.logger.Error("Failed to scan database rows",
				slog.String(logger.FieldOperation, "load_task"),
				slog.Int(logger.FieldUserID, userID),
				slog.String(logger.FieldError, err.Error()),
			)
			return nil, mapSQLiteError(err)
		}
		tasks = append(tasks, task)
	}

	if err = rows.Err(); err != nil {
		ds.logger.Error("Failed to query or scan database rows",
			slog.String(logger.FieldOperation, "load_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String(logger.FieldError, err.Error()),
		)
		return nil, mapSQLiteError(err)
	}

	return tasks, nil
}

// Close closes the database connection and releases resources.
func (ds *DatabaseStorage) Close() error {
	ds.logger.Debug("Close database connection",
		slog.String(logger.FieldOperation, "close"),
	)
	err := ds.db.Close()
	if err != nil {
		ds.logger.Error("Failed to close database connection",
			slog.String(logger.FieldOperation, "close"),
			slog.String(logger.FieldError, err.Error()),
		)
		return fmt.Errorf("failed to close database connection: %w", err)
	}
	ds.logger.Info("Database connection closed successfully",
		slog.String(logger.FieldOperation, "close"),
		slog.String("status", "success"),
	)
	return nil
}
