package storage

import (
	"database/sql"
	"errors"
	"log/slog"
	"myproject/logger"
	"os"
	"time"
)

var (
	ErrTaskNotFound = errors.New("task not found")
)

// Task represents a single task with unique ID, description, and completion status.
// All fields are JSON-serializable for API responses.
type Task struct {
	ID          int    `json:"id"`
	Description string `json:"description"`
	Done        bool   `json:"done"`
}

// Storage defines the interface for task persistence operations.
type Storage interface {
	LoadTasks(userID int) ([]Task, error)
	GetTaskByID(id int, userID int) (task Task, err error)
	CreateTask(task Task, userID int) (int, error)
	UpdateTask(task Task, userID int) error
	DeleteTask(id int, userID int) error
}

// DatabaseStorage provides SQLite-based task persistence with automatic schema management.
// It implements the Storage interface and handles database connections and migrations.
type DatabaseStorage struct {
	db       *sql.DB
	migrator *Migrator
	logger   *slog.Logger
}

// GetDatabasePath returns the database file path from environment or default location.
// Checks TASK_DB_PATH environment variable, falls back to "./tasks.db".
func GetDatabasePath() string {
	if dbPath := os.Getenv("TASK_DB_PATH"); dbPath != "" {
		return dbPath
	}
	return "./tasks.db"
}

// NewDatabaseStorage creates a new database storage instance with automatic setup.
// It handles connection pooling, schema migrations, and JSON data migration.
func NewDatabaseStorage(dbPath string, logger *slog.Logger) (*DatabaseStorage, error) {
	config := ConnectionConfig{
		MaxOpenConns:    25,
		MaxIdleConns:    5,
		ConnMaxLifetime: time.Hour,
		ConnMaxIdleTime: 15 * time.Minute,
	}
	db, err := CreateConnection(&config, dbPath)
	if err != nil {
		return nil, mapSQLiteError(err)
	}

	logger.Info("Database connection established",
		slog.String("db_path", dbPath),
	)

	migrator := NewMigratorWithDefaults(db)

	logger.Info("Applying database migrations")
	if err := migrator.ApplyMigrations(); err != nil {
		return nil, err
	}
	logger.Info("Database migrations completed")

	// Create storage instance
	storage := &DatabaseStorage{
		db:       db,
		migrator: migrator,
		logger:   logger,
	}
	return storage, nil
}

// CreateTask inserts a new task into the database and returns the generated ID.
// The database AUTOINCREMENT feature assigns the ID automatically.
// Timestamps (created_at, updated_at) are set to current time on creation.
func (ds *DatabaseStorage) CreateTask(task Task, userID int) (int, error) {
	desc := task.Description
	if len(task.Description) > 50 {
		desc = desc[:50]
	}
	ds.logger.Debug("Creating task",
		slog.String(logger.FieldOperation, "create_task"),
		slog.Int(logger.FieldUserID, userID),
		slog.String("description", desc),
	)
	result, err := ds.db.Exec(
		"INSERT INTO tasks (description, done, user_id, created_at, updated_at) VALUES (?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)",
		task.Description, task.Done, userID,
	)
	if err != nil {
		ds.logger.Error("Failed to execute database insert",
			slog.String(logger.FieldOperation, "create_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return 0, mapSQLiteError(err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		ds.logger.Error("Failed to return id generated by database",
			slog.String(logger.FieldOperation, "create_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return 0, mapSQLiteError(err)
	}
	return int(id), nil
}

func (ds *DatabaseStorage) UpdateTask(task Task, userID int) error {
	ds.logger.Debug("Updating task",
		slog.String(logger.FieldOperation, "update_task"),
		slog.Int(logger.FieldTaskID, task.ID),
		slog.Int(logger.FieldUserID, userID),
		slog.Bool("done", task.Done),
	)
	result, err := ds.db.Exec(
		"UPDATE tasks SET description = ?, done = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?",
		task.Description, task.Done, task.ID, userID,
	)
	if err != nil {
		ds.logger.Error("Failed to execute database update",
			slog.String(logger.FieldOperation, "update_task"),
			slog.Int(logger.FieldTaskID, task.ID),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return mapSQLiteError(err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		ds.logger.Error("Failed to affect database row",
			slog.String(logger.FieldOperation, "update_task"),
			slog.Int(logger.FieldTaskID, task.ID),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return mapSQLiteError(err)
	}

	if rowsAffected == 0 {
		return ErrTaskNotFound
	}

	return nil
}

func (ds *DatabaseStorage) DeleteTask(id int, userID int) error {
	ds.logger.Debug("Deleting task",
		slog.String(logger.FieldOperation, "delete_task"),
		slog.Int(logger.FieldTaskID, id),
		slog.Int(logger.FieldUserID, userID),
	)
	result, err := ds.db.Exec(
		"DELETE FROM tasks WHERE id = ? AND user_id = ?",
		id, userID,
	)
	if err != nil {
		ds.logger.Error("Failed to execute database delete",
			slog.String(logger.FieldOperation, "delete_task"),
			slog.Int(logger.FieldTaskID, id),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return mapSQLiteError(err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		ds.logger.Error("Failed to affect database row",
			slog.String(logger.FieldOperation, "delete_task"),
			slog.Int(logger.FieldTaskID, id),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return mapSQLiteError(err)
	}

	if rowsAffected == 0 {
		return ErrTaskNotFound
	}

	return nil
}

func (ds *DatabaseStorage) GetTaskByID(id int, userID int) (task Task, err error) {
	ds.logger.Debug("Fetching task",
		slog.String(logger.FieldOperation, "get_task_by_id"),
		slog.Int(logger.FieldTaskID, id),
		slog.Int(logger.FieldUserID, userID),
	)
	err = ds.db.QueryRow(
		"SELECT id, description, done FROM tasks WHERE id = ? AND user_id = ?",
		id, userID,
	).Scan(&task.ID, &task.Description, &task.Done)

	if err != nil {
		if err == sql.ErrNoRows {
			return task, ErrTaskNotFound
		}
		ds.logger.Error("Failed to query database select",
			slog.String(logger.FieldOperation, "get_task_by_id"),
			slog.Int(logger.FieldTaskID, id),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return task, mapSQLiteError(err)
	}

	return task, nil
}

// LoadTasks retrieves all tasks from the database ordered by ID.
// Returns an empty slice if no tasks exist, never returns nil.
func (ds *DatabaseStorage) LoadTasks(userID int) ([]Task, error) {
	ds.logger.Debug("Loading tasks",
		slog.String(logger.FieldOperation, "load_task"),
		slog.Int(logger.FieldUserID, userID),
	)
	query := "SELECT id, description, done FROM tasks WHERE user_id = ? ORDER BY id"
	rows, err := ds.db.Query(query, userID)
	if err != nil {
		ds.logger.Error("Failed to query database select",
			slog.String(logger.FieldOperation, "load_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return nil, mapSQLiteError(err)
	}

	defer rows.Close()
	tasks := make([]Task, 0)
	for rows.Next() {
		var task Task
		if err := rows.Scan(&task.ID, &task.Description, &task.Done); err != nil {
			ds.logger.Error("Failed to scan database rows",
				slog.String(logger.FieldOperation, "load_task"),
				slog.Int(logger.FieldUserID, userID),
				slog.String("error", err.Error()),
			)
			return nil, mapSQLiteError(err)
		}
		tasks = append(tasks, task)
	}

	if err = rows.Err(); err != nil {
		ds.logger.Error("Failed to query or scan database rows",
			slog.String(logger.FieldOperation, "load_task"),
			slog.Int(logger.FieldUserID, userID),
			slog.String("error", err.Error()),
		)
		return nil, mapSQLiteError(err)
	}

	return tasks, nil
}
